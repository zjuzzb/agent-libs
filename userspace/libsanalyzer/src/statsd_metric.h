/**
 * @file
 *
 * Interface to statsd_metric.
 *
 * @copyright Copyright (c) 2015-2019 Sysdig Inc., All Rights Reserved
 */
#pragma once

#include <cstdint>
#include <map>
#include <string>
#include <stdexcept>

namespace draiosproto
{
class statsd_metric;
}

/**
 * Models a single statsd metric, as generated by statsite.  The output
 * of statsite looks generally like:
 *
 * <pre>
 * metric_type.metric_name|metric_value|timestamp
 * </pre>
 *
 * The metric_name portion can include the container id and tags.
 *
 * Some concrete examples:
 *
 * Counter metric
 * <pre>
 * counts.metric_name|1.000000|1563375378
 * </pre>
 *
 * Gauge metric
 * <pre>
 * gauges.metric_name|1.000000|1563375378
 * </pre>
 *
 * Set metric
 * <pre>
 * sets.metric_name|1.000000|1563375378
 * </pre>
 *
 * Histogram metric come as a sequence of lines, each including one of the
 * values of interest:
 * <pre>
 * timers.metric_name.sum|1.000000|1563375378
 * timers.metric_name.sum_sq|1.000000|1563375378
 * timers.metric_name.mean|1.000000|1563375378
 * timers.metric_name.lower|1.000000|1563375378
 * timers.metric_name.upper|1.000000|1563375378
 * timers.metric_name.count|1|1563375378
 * timers.metric_name.stdev|0.000000|1563375378
 * timers.metric_name.median|1.000000|1563375378
 * timers.metric_name.p50|1.000000|1563375378
 * timers.metric_name.p95|1.000000|1563375378
 * timers.metric_name.p99|1.000000|1563375378
 * timers.metric_name.rate|1.000000|1563375378
 * timers.metric_name.sample_rate|1.000000|1563375378
 * </pre>
 *
 * We prepend the container id to the metric name for containers, so metrics
 * for containers will look like the following for a count metric (the
 * others are similar):
 *
 * <pre>
 * counts.containerid$metric_name|1.000000|1563375378
 * <pre>
 *
 * Metric names can also have 0 or more tags, each of which may have an
 * associated value.  Examples:
 *
 * <pre>
 * counts.metric_name#tag_name|1.000000|1563375378
 * counts.metric_name#tag_name=tag_value|1.000000|1563375378
 * counts.metric_name#tag_name1=tag_value1,tag_name2=tag_value2|1.000000|1563375378
 * counts.containerid$metric_name#tag_name=tag_value|1.000000|1563375378
 * <pre>
 */
class statsd_metric
{
public:
	/**
	 * Thrown by parse_line() in the event a parsing error occurs.
	 */
	class parse_exception : public std::runtime_error
	{
	public:
		explicit parse_exception(const std::string& msg);
	};

	/**
	 * The various types of metrics.
	 */
	enum class type_t
	{
		NONE = 0,
		COUNT = 1,
		HISTOGRAM = 2,
		GAUGE = 3,
		SET = 4,
	};

	/**
	 * Initializes this statsd_metric to a known initial state.
	 */
	statsd_metric();

	/**
	 * Writes the content of this statsd_metric to the given protobuf.
	 */
	void to_protobuf(draiosproto::statsd_metric* proto) const;

	/**
	 * Parses the given line and populates this statsd_metric%'s fields
	 * appropriately.  For COUNT, GAUGE, and SET metrics, this will be
	 * called only once.  For HISTOGRAM, this will be called for each
	 * line that contributes to a single histogram metric.
	 *
	 * @return false if line does not belong to this object
	 * @throws a parse_exception if parsing fails
	 */
	bool parse_line(const std::string& line);

	/** Returns the timestamp associated with this statsd_metric. */
	uint64_t timestamp() const;

	/** Returns the name of statsd_metric. */
	const std::string& name() const;

	/**
	 * Returns the container id of this statsd_metric, or the empty string
	 * if this statsd_metric is associated with the host.
	 */
	const std::string& container_id() const;

	/** Returns the type of statsd_metric. */
	type_t type() const;

	/**
	 * Returns the value of this statsd_metric. This value has meaning only
	 * for metrics of type COUNT, GAUGE, or SET.
	 */
	double value() const;

	/**
	 * Returns the sum of this statsd_metric. This value has meaning only
	 * for metrics of type HISTOGRAM.
	 */
	double sum() const;

	/**
	 * Returns the mean of this statsd_metric. This value has meaning only
	 * for metrics of type HISTOGRAM.
	 */
	double mean() const;

	/**
	 * Returns the min of this statsd_metric. This value has meaning only
	 * for metrics of type HISTOGRAM.
	 */
	double min() const;

	/**
	 * Returns the max of this statsd_metric. This value has meaning only
	 * for metrics of type HISTOGRAM.
	 */
	double max() const;

	/**
	 * Returns the count of this statsd_metric. This value has meaning only
	 * for metrics of type HISTOGRAM.
	 */
	double count() const;

	/**
	 * Returns the stdev of this statsd_metric. This value has meaning only
	 * for metrics of type HISTOGRAM.
	 */
	double stdev() const;

	/**
	 * Returns the given percentile of this statsd_metric.  If this
	 * statsd_metric does not have the given percentile, then this returns
	 * 0.0.  This value has meaning only for metrics of type HISTOGRAM.
	 */
	double percentile(int index) const;

	/**
	 * Returns the given percentile of this statsd_metric in value.  If this
	 * statsd_metric does not have the given percentile, then it leaves
	 * val unchanged.  This value has meaning only for metrics of type
	 * HISTOGRAM.
	 *
	 * @returns true if this statsd_metric has a the given pct, false
	 *          otherwise.
	 */
	bool percentile(int pct, double& val);

	/**
	 * Returns the tags associated with this statsd_metric.
	 */
	const std::map<std::string, std::string>& tags() const;

	/**
	 * Returns a debug string representation of this statsd_metric.
	 */
	std::string to_debug_string() const;

	/**
	 * Sanitizes container IDs by substituting symbols that are special
	 * to the statsd protocol with other symbols.
	 *
	 * @returns the sanitized container id.
	 */
	static std::string sanitize_container_id(std::string container_id);

	/**
	 * Reverses any modifications made by sanitize_container_id().
	 *
	 * @returns the restored original container id.
	 */
	static std::string desanitize_container_id(std::string container_id);

	/**
	 * Returns a string representation of the given statsd_metric type.
	 */
	static std::string type_to_string(const statsd_metric::type_t type);

	/**
	 * The symbol used to separate container IDs from metric names.
	 */
	static const char CONTAINER_ID_SEPARATOR = '$';

private:
	uint64_t m_timestamp;
	std::string m_name;
	std::map<std::string, std::string> m_tags;
	std::string m_container_id;
	type_t m_type;
	bool m_full_identifier_parsed;
	double m_value;
	double m_sum;
	double m_mean;
	double m_min;
	double m_max;
	double m_count;
	double m_stdev;
	std::map<int, double> m_percentiles;

	friend class lua_cbacks;
};
